---
title: "Introduction to NAHRtoolkit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introductin}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  options(tibble.print_min = 4, tibble.print_max = 4)
)
```

```{r setup}
library(nahrtoolkit)
```

NAHRtoolkit provides functions to generate sequences with repetitive elements, 
invoke minimap2 to spot repeats and run tree-like algorithms to detect likely
repeat-mediated SVs. 

## Big weaknesses in implementation

bbmap shred.sh script is kinda needed but not properly installed/referred.


## Example use cases.

### `confirm_loaded_nahr()`: Check if loading has been successful

`nahrtoolkit::confirm_loaded_nahr()` Tests if loading has been successful.

```{r}
confirm_loaded_nahr()
```

### Use case 1: Make a dotplot visualisation of two fasta files. 


We start with creating two dotplots of a fasta file with itself. First, let us specify an example sequence.
(Note: the example sequence has been created from the commandline, using: 
Rscript seqbuilder_wrapper.R -l 10000 -s ../data/sds10y.tsv -o 10ktest
)

```{r}
samplefasta_link = system.file('extdata', '10ktest.fa', package='nahrtoolkit')
samplepaf_link = paste0(samplefasta_link, '.paf')
```

If the sequence is not too long, we can use an exact dotplot to visualize the ground truth.

```{r}

exact_plot = make_dotplot(samplefasta_link, samplefasta_link, 10, save=F)
print(exact_plot)
```

Alternatively, if the sequences are very long, we can also use Minimap2 to generate us a dotplot. Note how segdups are being highlighted. 

```{r, warning = FALSE, message = FALSE}

minimap2_inferred_plot = 
  make_chunked_minimap_alnment(samplefasta_link, samplefasta_link, samplepaf_link, 
                               chunklen = 500, saveplot=F, 
                               hllink = samplepaf_link, hltype = 'paf')


print(minimap2_inferred_plot)
```


### Use case 2: Sequence simulation and modification
#### 2.1: Simulate a sequence with SDs. 

NAHRtoolkit can also simulate a new sequence. What we need for this is a .tsv file containing specifications for the desired SDs. 

```{r, warning = FALSE, message = FALSE}

seqlen = 10000
sdfile_bed = system.file('extdata', 'sds10.bed', package='nahrtoolkit')
outfasta = './simulated_seq_10kb.fa'

sdfile_tsv = './sds10.tsv'
# Turn the easy-to-write .bed file into a .tsv file 
convert_bed_to_tsv(sdfile_bed, sdfile_tsv)

## MAKE THE SEQUENCE
simulate_seq(seqlen, sdfile_tsv, outfasta)

# Make an exact dotplot, in case this is feasible.
if (seqlen <= 25000){
  exact_plot = make_dotplot(outfasta, outfasta, 15, save=F)
  print(exact_plot)
}
```

#### 2.2: Introduce mutations to a simulated sequence. 

We can use a simple text file with two columns [SDname, Operation] to specify mutations we would like to see. Let's start with a simple inversion:

```{r, warning = FALSE, message = FALSE}

svfile_invA = system.file('extdata', 'SDa_inv.txt', package='nahrtoolkit')

outmutfasta = './simulated_seq_10kb_inv.fa'
outmutsd = './simulated_seq_10kb_inv.tsv'
mutate_seq(outfasta, sdfile_tsv, svfile_invA, outmutfasta, outmutsd)

if (seqlen <= 25000){
  exact_plot = make_dotplot(outfasta, outmutfasta, 15, save=F)
  print(exact_plot)
}
```

We can also make the same dotplot with alignments from minimap2: 

```{r, warning = FALSE, message = FALSE}
samplepaf_link ='./simulated_seq_10kb_mm2.paf'

make_chunked_minimap_alnment(outfasta, outmutfasta, samplepaf_link, 
                             chunklen = 5000, minsdlen = 0, saveplot=F, 
                             hllink = samplepaf_link, hltype = 'paf', quadrantsize = 500000)
```

Next, we initiate a more complex sequence with four SD pairs, and introduce various mutations.

```{r, warning = FALSE, message = FALSE}

seqlen = 10000
sdfile_tsv = system.file('extdata', 'sds10_4SDs.tsv', package='nahrtoolkit')
outfasta = './simulated_seq_10kb_4SDs.fa'


## MAKE THE SEQUENCE
simulate_seq(seqlen, sdfile_tsv, outfasta)

# Make an exact dotplot, in case this is feasible.
if (seqlen <= 25000){
  exact_plot = make_dotplot(outfasta, outfasta, 15, save=F)
  print(exact_plot + ggplot2::labs(title='Simulated Sequence #2. Four SD pairs.'))
}

# First: A deletion on SDC
svfile_delC = system.file('extdata', 'SDc_del.txt', package='nahrtoolkit')

outmutfasta = './simulated_seq_10kb_del.fa'
outmutsd = './simulated_seq_10kb_del.tsv'
mutate_seq(outfasta, sdfile_tsv, svfile_delC, outmutfasta, outmutsd)

if (seqlen <= 25000){
  exact_plot = make_dotplot(outfasta, outmutfasta, 15, save=F)
  print(exact_plot + ggplot2::labs(title='Seq #2, Mutation #1: deletion on SDC'))
}

# Next, let's duplicate on that same SD pair. 
svfile_dupC = system.file('extdata', 'SDc_dup.txt', package='nahrtoolkit')

outmutfasta = './simulated_seq_10kb_dup.fa'
outmutsd = './simulated_seq_10kb_dup.tsv'
mutate_seq(outfasta, sdfile_tsv, svfile_dupC, outmutfasta, outmutsd)

if (seqlen <= 25000){
  exact_plot = make_dotplot(outfasta, outmutfasta, 15, save=F)
  print(exact_plot + ggplot2::labs(title='Seq #2, Mutation #2: duplication on SDC'))
}
```
As a last example, let's create at a sequence with two nested SD pairs: 

```{r, warning = FALSE, message = FALSE}

seqlen = 10000
sdfile_bed = system.file('extdata', 'sds_twonest.bed', package='nahrtoolkit')

outfasta = './simulated_seq_twonest.fa'

sdfile_tsv = './sds_twonest.tsv'
# Turn the easy-to-write .bed file into a .tsv file 
convert_bed_to_tsv(sdfile_bed, sdfile_tsv)

## MAKE THE SEQUENCE
simulate_seq(seqlen, sdfile_tsv, outfasta)

# Make an exact dotplot, in case this is feasible.
if (seqlen <= 25000){
  exact_plot = make_dotplot(outfasta, outfasta, 15, save=F)
  print(exact_plot  + ggplot2::labs(title='Simulated Sequence #3. Two nested SD pairs in indirect orientation.'))
}
```

There are no SDs in direct orientation, hence no CNVs are possible right now. However, we could invert on one SD first, and then duplicate on the other. Let's try: 

```{r, warning = FALSE, message = FALSE}
svfile_invA = system.file('extdata', 'SDa_inv.txt', package='nahrtoolkit')
svfile_dupB = system.file('extdata', 'SDb_dup.txt', package='nahrtoolkit')

outmutfasta = './simulated_seq_twonest_inv.fa'
outmutsd = './simulated_seq_twonest_inv.tsv'
outmutfasta2 = './simulated_seq_twonest_inv_dup.fa'
outmutsd2 = './simulated_seq_twonest_inv_dup.tsv'
# Notice how a dup on SDB is not possible upfront:
try(mutate_seq(outfasta, sdfile_tsv, svfile_dupB, outmutfasta, outmutsd))


mutate_seq(outfasta, sdfile_tsv, svfile_invA, outmutfasta, outmutsd)
mutate_seq(outmutfasta, outmutsd, svfile_dupB, outmutfasta2, outmutsd2)

# Let's have a look at the resulting sequence. We plot it against the orig seq. 

if (seqlen <= 25000){
  exact_plot = make_dotplot(outfasta, outmutfasta2, 15, save=F) + ggplot2::labs(title='Simulated Sequence #3. Double mutation: INV + DUP')
  print(exact_plot)
}
```

### 3: Compress dotplots

Next, we will look at compressed dotplots. We take the previous example, and turn it into a condensed dotplot. 

```{r, warning = FALSE, message = FALSE}



outpaf_link ='./4SDs_inv_dup.paf'

make_chunked_minimap_alnment(outfasta, outmutfasta2, outpaf_link,
                             chunklen = 1000, minsdlen = 0, saveplot=F,
                             hllink = F, hltype = F, quadrantsize = 500000)
# Make the condensed dotplot
grid = wrapper_paf_to_bitlocus(outpaf_link, minlen=100, compression = 100)

```

From this compressed dotplot, we can now explore the mutation space, to find chains of rearrangements (acted on the x-axis, typically REF) which can explain the picture. In our case, we know we have simulated an inversion, followed by a duplication. Let's try to recapitulate that with explore_mutation_space:

```{r, warning = FALSE, message = FALSE}

# This is a data transformation part: we want to go from a 'gridlist' with x,y,z
# coordinates to a matrix. 
gridmatrix = gridlist_to_gridmatrix(grid[[3]])

# Run a mutation search on the matrix
res = explore_mutation_space(gridmatrix, depth = 2)

# Print the results with the highest evaluation score
print(res[res$eval == max(res$eval),])

```



### 4: Working with assemblies / large sequences


Up to this point, we have assumed that we have always two input fasta files containing only the region of interest. In a real-world scenario, however, it is more likely that you are dealing with a genome assembly, and are interested in a certain sequence from the reference genome. To accomodate these needs, we will make use of the two 'liftover'-esque functions:

"liftover_coarse" and "extract_subseq_bedtools"

liftover_coarse takes as input a reference coordinate interval (e.g. from hg38), and a PRECOMPUTED alignment between an assembly and the reference. 
The precomputed alignment (ca 10Mb for a whole genome) is too coarse to do variant calling from it, but we use it to find which part of the assembly
matches best to our input region. 

The following piece of code: 
1) Sets the paths to an assembly fasta, and an assembly-hg38-alignment.paf
2) Uses coords_assembly to find a sequence from hg38 on the assembly.
3) Uses extract_subseq_bedtools to make a new fasta, from the assembly, containing the sequence of interest. 





```{r, warning = FALSE, message = FALSE}
# In the example files shipped with nahrtoolkit, we find a fasta file containing two contigs from a real assembly. 
# We have previously mapped this partial assembly to an hg38 reference genome with minimap: 
# minimap2 -t 8 -cx asm20 assembly.fa hg38.fa > alignment_assembly_hg38.paf

# Define path to assembly fasta and alignment paf
assembly_fa = system.file('extdata', 'asm_2contigs_HG00512.fa', package='nahrtoolkit')
hg38_fa = system.file('extdata', 'hg38_chr11_120m_124m.fa', package='nahrtoolkit')

alignment_asm_hg38_paf = system.file('extdata', 'asm_2contigs_HG00512_hg38.paf', package='nahrtoolkit')


# Define output files
outpaf_link = './deleteme.tmp'
assembly_outfasta_region = './assembly_outfasta_region.fa'
hg38_outfasta_region = './hg38_region_extract.fa'

# Input coordinates on hg38
seqname = 'chr11'
start   = 120010000
end     = 120100000

# Run the liftover. (lenfactor > 1: extract more surrounding. E.g. 1.5 for 50% on both sides)
coords_assembly = liftover_coarse(seqname, 
                                  start, 
                                  end, 
                                  alignment_asm_hg38_paf, 
                                  lenfactor = 1)

# Extract a fasta file from the assembly, which contains only the segment of interest:
extract_subseq_bedtools(assembly_fa, 
                        coords_assembly$lift_contig, 
                        coords_assembly$lift_start, 
                        coords_assembly$lift_end, 
                        assembly_outfasta_region)


```

We have now created a new fasta file (assembly_outfasta_region; aka './assembly_outfasta_region.fa') which contains the sequence from the assembly that most closely matches hg38:chr11:12001000-120100000.
Let us plot the sequence against itself to see if we find any repeat patterns: 

```{r, warning = FALSE, message = FALSE}

# assembly alignment against self
asm_asm_plot = make_chunked_minimap_alnment(assembly_outfasta_region, assembly_outfasta_region, outpaf_link,
                             chunklen = 1000, minsdlen = 2000, saveplot=F,
                             hllink = F, hltype = F)#, wholegenome = F)

print(asm_asm_plot)

# Condensed plots if you are interested...
# grid = wrapper_paf_to_bitlocus(outpaf_link, minlen = 100, compression = 1000)#[[3]] -->
# gridmatrix = gridlist_to_gridmatrix(grid[[3]]) -->
# res = explore_mutation_space(gridmatrix, depth = 2) -->
# print(res[res$eval == max(res$eval),]) -->

```


Indeed! We see a highly repetitive blob of sequence in the middle of the plot. 
We could now follow this up by comparing the sequence to other sequences, e.g. hg38. 








