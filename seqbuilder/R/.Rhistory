#' -z   Z-drop score. [-1]
#' -Z   Z-drop inversion score. [-1]
#' -r   Bandwidth used in chaining and DP-based alignment. [-1]
#' -g   Stop chain enlongation if there are no minimizers in N bp. [-1]
#' #'
#' @param targetfasta [character/link] link to the 'target' single-sequence fasta (sometimes reference, e.g. chm13.)
#' @param queryfasta [character/link] link to the 'query' fasta. Can be single or multi-fasta
#' @param outpaf [character/link] Path to the output paffile to be written.
#' @param minimap2loc [character/link] link to minimap2 binary.
#' @return nothing. Only output files written.
#'
#' @author Wolfram Höps
#' @rdname alignment
#' @export
run_minimap2 <- function(targetfasta, queryfasta, outpaf, minimap2loc = "/Users/hoeps/opt/anaconda3/bin/minimap2"){
#system(paste0(minimap2loc," -x asm20 -c -z400,50 -s 0 -M 0.2 -N 100 -P --hard-mask-level ", fastatarget, " ", fastaquery, " > ", outpaf))
# Some self-defined parameters
system(paste0(minimap2loc," -x asm20 -P -c -s 0 -M 0.2 ", targetfasta, " ", queryfasta, " > ", outpaf))
#pbmm2: CCS/HIFI
#system(paste0(minimap2loc," -k 19 -w 10 -u -o 5 -O 56 -e 4 -E 1 -A 2 -B 5 -z 400 -Z 50 -r 2000 -L 0.5 -g 5000", targetfasta, " ", queryfasta, " > ", outpaf))
# W, 23rd Dec 2021. Since the dev of pbmm2, the minimap2 parameters have changed. I adapted everything to the new notation.
# the -L paramter (formerly Long join flank ratio) is no longer existing, so I'm leaving it out.
#system(paste0(minimap2loc," -k 19 -w 10 -O 5,56 -E 4,1 -A 2 -B 5 -z 400,50 -r 2000 -g 5000 ", targetfasta, " ", queryfasta, " > ", outpaf))
}
#' Submit a system command to run awk to change sequence chunk names
#'
#' @description This is a helperfunction to run awk
#'
#' @param inpaf [character/link] input paf
#' @param outpaf [character/link] output paf
#'
#' @return nothing. Only output files written.
#'
#' @author Wolfram Höps
#' @rdname alignment
#' @export
awk_edit_paf <- function(inpaf, outpaf,
scriptlink = '/Users/hoeps/PhD/projects/nahrcall/nahrchainer/seqbuilder/scripts/awk_on_paf.sh'){
print(inpaf)
print(outpaf)
system(paste0(scriptlink, " ", inpaf, " ", outpaf))
}
#' Helperfunction to save a fasta file.
#'
#' @description a simple function that takes a data.frame that has a column name
#' and seq and writes a fasta file from it. Taken from
#' https://bootstrappers.umassmed.edu/guides/main/r_writeFasta.html.
#'
#' @param data [character/link] data frame with column 'name' and 'seq'
#' @param filename [character/link] output filename.
#'
#' @return nothing. Only output files written.
#'
#' @author Nicholas Hathaway
#' @rdname alignment
#' @export
writeFasta<-function(data, filename){
fastaLines = c()
for (rowNum in 1:nrow(data)){
fastaLines = c(fastaLines, as.character(paste(">", data[rowNum,"name"], sep = "")))
fastaLines = c(fastaLines,as.character(data[rowNum,"seq"]))
}
fileConn<-file(filename)
writeLines(fastaLines, fileConn)
close(fileConn)
}
#' helperfunction to shorten a fasta file.
#' @author Nicholas Hathaway
#' @rdname alignment
#' @export
shorten_fasta <- function(infasta, outfasta, range){
input = read.table(infasta)
seq = as.character(Biostrings::readDNAStringSet(infasta))
seq_shortened = substr(seq,range[1],range[2])
writeFasta(data.frame(name='seq', seq=seq_shortened), filename=outfasta)
print('Successfully written sub-fasta')
}
#' https://rdrr.io/cran/insect/src/R/complement.R
#' Reverse complement DNA in character string format.
#'
#' This function reverse complements a DNA sequence or vector of DNA
#'   sequences that are stored as character strings.
#'
#' @param z a vector of DNA sequences in upper case character string format.
#' @return a vector of DNA sequences as upper case character strings.
#' @details This function accepts only DNA sequences in concatenated character
#'   string format, see \code{\link[ape]{complement}} in the \code{\link[ape]{ape}}
#'   package for "DNAbin" input objects, and \code{\link[seqinr]{comp}} in the
#'   \code{\link[seqinr]{seqinr}} package for when the input object is a character
#'   vector.
#' @author Shaun Wilkinson
#' @examples rc("TATTG")
################################################################################
rc <- function(z){
rc1 <- function(zz){
s <- strsplit(zz, split = "")[[1]]
s <- rev(s)
dchars <- strsplit("ACGTMRWSYKVHDBNI", split = "")[[1]]
comps <- strsplit("TGCAKYWSRMBDHVNI", split = "")[[1]]
s <- s[s %in% dchars] # remove spaces etc
s <- dchars[match(s, comps)]
s <- paste0(s, collapse = "")
return(s)
}
z <- toupper(z)
tmpnames <- names(z)
res <- unname(sapply(z, rc1))
if(!is.null(attr(z, "quality"))){
strev <- function(x) sapply(lapply(lapply(unname(x), charToRaw), rev), rawToChar)
attr(res, "quality") <- unname(sapply(attr(z, "quality"), strev))
}
names(res) <- tmpnames
return(res)
}
################################################################################
#' Create a simple random sequence.
#'
#' @description Simple function to create a random string of ACGT.
#'
#' @param n [numeric] length of desired sequence (bp)
#' @param gcfreq [character/link] desired GC frequency.
#' @return A character vector of a random DNA sequence.
#'
#' @author Wolfram Höps
#' @rdname seq_modeling
#' @export
randDNASeq <- function(n, gcfreq, seed=1234){
bases= c('A','C','G','T')
set.seed(seed)
seq = sample(bases, n, replace=T,
prob = c((1-gcfreq)/2, gcfreq/2, gcfreq/2, (1-gcfreq)/2) )
return(paste(seq, collapse=''))
}
make_alu_dp_mm2 <- function(inv, sample, r, bp, buffer, outpath){
ref = paste0('/Users/hoeps/PhD/projects/huminvs/revision/alu_analysis/data/seqs/',inv,'/', inv, '_hg38_pm200kb.fa')
if (r == T){
alt = paste0('/Users/hoeps/PhD/projects/huminvs/revision/alu_analysis/data/seqs/', inv, '/', inv, '_', sample, '_rev.fa')
} else {
alt = paste0('/Users/hoeps/PhD/projects/huminvs/revision/alu_analysis/data/seqs/', inv, '/', inv, '_', sample, '.fa')
}
outpaf_link = paste0('/Users/hoeps/PhD/projects/huminvs/revision/alu_analysis/data/dotplots_mm/', sample, inv, '.paf')
make_chunked_minimap_alnment(ref, alt, outpaf_link,
outplot=NULL, chunklen = 100, minsdlen = 5000, saveplot=T,
hllink = outpaf_link, hltype = 'paf', quadrantsize = 20000,
targetrange=c(bp[1]-buffer, bp[2]+buffer),
queryrange=c(bp[3]-buffer , bp[4]+buffer))
}
make_alu_dp_mm2(to_plot$inv, to_plot$sample, to_plot$r, to_plot$bp, to_plot$buffer, to_plot$outpath)
make_alu_dp_mm2 <- function(inv, sample, r, bp, buffer, outpath){
ref = paste0('/Users/hoeps/PhD/projects/huminvs/revision/alu_analysis/data/seqs/',inv,'/', inv, '_hg38_pm200kb.fa')
if (r == T){
alt = paste0('/Users/hoeps/PhD/projects/huminvs/revision/alu_analysis/data/seqs/', inv, '/', inv, '_', sample, '_rev.fa')
} else {
alt = paste0('/Users/hoeps/PhD/projects/huminvs/revision/alu_analysis/data/seqs/', inv, '/', inv, '_', sample, '.fa')
}
outpaf_link = paste0('/Users/hoeps/PhD/projects/huminvs/revision/alu_analysis/data/dotplots_mm/', sample, inv, '.paf')
make_chunked_minimap_alnment(ref, alt, outpaf_link,
outplot=NULL, chunklen = 100, minsdlen = 5000, saveplot=T,
hllink = outpaf_link, hltype = 'paf', quadrantsize = 20000,
targetrange=c(bp[1]-buffer, bp[2]+buffer),
queryrange=c(bp[3]-buffer , bp[4]+buffer))
}
for (invname in c('invchr1', 'invchr3', 'invchr8', 'invchr9',
'invchr12_1', 'invchr12_2', 'invchr16', 'invchr17',
'invchr21')){
to_plot = get(invname)
#make_alu_dp(to_plot$inv, to_plot$sample, to_plot$r, to_plot$bp, to_plot$buffer, to_plot$outpath)
make_alu_dp_mm2(to_plot$inv, to_plot$sample, to_plot$r, to_plot$bp, to_plot$buffer, to_plot$outpath)
}
# Whoeps, 8th Jan 2021
find_x_intersection <- function(vectors, point){
#vectors = paf
#point = as.numeric(paf[1,c('tend', 'qend')])
x_overlap = NULL
#vectors = data.frame(xstart = 2, xend = 4, ystart = 6, yend = 8)
#point = c(5,7)
overlap_vecs = vectors[(vectors$qstart < point[2]) & (vectors$qend > point[2]),]
if (dim(overlap_vecs)[1] == 0){
# Early return if there is no overlap
return(point[1])
}
# If there is overlap, calculate overlap of point with every overlapper
x_overlap = c(point[1])
for (i in 1:dim(overlap_vecs)[1]){
vec = overlap_vecs[i,]
dy = vec$qend - vec$qstart
dx = vec$tend - vec$tstart
m = dy/dx
c = vec$qstart - (m * vec$tstart)
x_i = (point[2] - c) / m
x_overlap = c(x_overlap, x_i)
}
return(x_overlap)
}
find_y_intersection <- function(vectors, point){
#vectors = paf
#point = as.numeric(paf[1,c('tend', 'qend')])
x_overlap = NULL
#vectors = data.frame(xstart = 2, xend = 4, ystart = 6, yend = 8)
#point = c(5,7)
overlap_vecs = vectors[(vectors$tstart < point[1]) & (vectors$tend > point[1]),]
if (dim(overlap_vecs)[1] == 0){
# Early return if there is no overlap
return(point[2])
}
# If there is overlap, calculate overlap of point with every overlapper
x_overlap = c(point[2])
for (i in 1:dim(overlap_vecs)[1]){
vec = overlap_vecs[i,]
dy = vec$tend - vec$tstart
dx = vec$qend - vec$qstart
m = dy/dx
c = vec$tstart - (m * vec$qstart)
x_i = (point[1] - c) / m
x_overlap = c(x_overlap, x_i)
}
return(x_overlap)
}
# Turn tsv into bitlocus.
origfa = '../vignettes/simulated_seq_10kb_4SDs.fa'
mutfa = '../vignettes/simulated_seq_10kb_del_trim.fa'
#mutfa = '../vignettes/mut.fa'
outpaf = '../vignettes/bitlocus8.paf'
plot = make_chunked_minimap_alnment(origfa, mutfa, outpaf,
outplot=NULL, chunklen = 1000, minsdlen = 10, saveplot=F,
hllink = outpaf, hltype = 'paf', quadrantsize = 1000)
setwd("~/PhD/projects/nahrcall/nahrchainer/seqbuilder/R")
# Whoeps, 8th Jan 2021
find_x_intersection <- function(vectors, point){
#vectors = paf
#point = as.numeric(paf[1,c('tend', 'qend')])
x_overlap = NULL
#vectors = data.frame(xstart = 2, xend = 4, ystart = 6, yend = 8)
#point = c(5,7)
overlap_vecs = vectors[(vectors$qstart < point[2]) & (vectors$qend > point[2]),]
if (dim(overlap_vecs)[1] == 0){
# Early return if there is no overlap
return(point[1])
}
# If there is overlap, calculate overlap of point with every overlapper
x_overlap = c(point[1])
for (i in 1:dim(overlap_vecs)[1]){
vec = overlap_vecs[i,]
dy = vec$qend - vec$qstart
dx = vec$tend - vec$tstart
m = dy/dx
c = vec$qstart - (m * vec$tstart)
x_i = (point[2] - c) / m
x_overlap = c(x_overlap, x_i)
}
return(x_overlap)
}
find_y_intersection <- function(vectors, point){
#vectors = paf
#point = as.numeric(paf[1,c('tend', 'qend')])
x_overlap = NULL
#vectors = data.frame(xstart = 2, xend = 4, ystart = 6, yend = 8)
#point = c(5,7)
overlap_vecs = vectors[(vectors$tstart < point[1]) & (vectors$tend > point[1]),]
if (dim(overlap_vecs)[1] == 0){
# Early return if there is no overlap
return(point[2])
}
# If there is overlap, calculate overlap of point with every overlapper
x_overlap = c(point[2])
for (i in 1:dim(overlap_vecs)[1]){
vec = overlap_vecs[i,]
dy = vec$tend - vec$tstart
dx = vec$qend - vec$qstart
m = dy/dx
c = vec$tstart - (m * vec$qstart)
x_i = (point[1] - c) / m
x_overlap = c(x_overlap, x_i)
}
return(x_overlap)
}
# Turn tsv into bitlocus.
origfa = '../vignettes/simulated_seq_10kb_4SDs.fa'
mutfa = '../vignettes/simulated_seq_10kb_del_trim.fa'
#mutfa = '../vignettes/mut.fa'
outpaf = '../vignettes/bitlocus8.paf'
#samplefasta_link = system.file('extdata', '10ktest.fa', package='nahrtoolkit')
plot = make_chunked_minimap_alnment(origfa, mutfa, outpaf,
outplot=NULL, chunklen = 1000, minsdlen = 10, saveplot=F,
hllink = outpaf, hltype = 'paf', quadrantsize = 1000)
# Read paf
paf = read.table(outpaf)
colnames(paf) = c('qname','qlen','qstart','qend',
'strand','tname','tlen','tstart',
'tend','nmatch','alen','mapq')
paf = transform(paf,
tend = ifelse(strand == '-', tstart, tend),
tstart = ifelse(strand == '-', tend, tstart))
# Let's do it slow and bad for now. This doesn't seem to be very time critical anyway
# because it only has to be run once per locus.
gridlines_x = c()
for (i in 1:dim(paf)){
print(i)
gridlines_x = c(gridlines_x, find_x_intersection(paf, as.numeric(paf[i,c('tstart', 'qstart')])))
gridlines_x = c(gridlines_x, find_x_intersection(paf, as.numeric(paf[i,c('tend', 'qend')])))
print(gridlines_x)
}
gridlines_x = sort(unique(gridlines_x))
gridlines_y = c()
for (i in 1:dim(paf)){
print(i)
gridlines_y = c(gridlines_y, find_y_intersection(paf, as.numeric(paf[i,c('tstart', 'qstart')])))
gridlines_y = c(gridlines_y, find_y_intersection(paf, as.numeric(paf[i,c('tend', 'qend')])))
print(gridlines_y)
}
gridlines_y = sort(unique(gridlines_y))
plot + ggplot2::xlim(c(0,10000)) + ggplot2::ylim(c(0,10000)) +
ggplot2::geom_hline(yintercept=gridlines_y) +
ggplot2::geom_vline(xintercept=gridlines_x)
grid
ggplot2::ggplot() + ggplot2::geom_segment(data = paf[paf$strand=='+',], ggplot2::aes(x=tstart, xend = tend, y=qstart, yend=qend)) +
ggplot2::geom_segment(data = paf[paf$strand=='-',], ggplot2::aes(x=tstart, xend = tend, y=qend, yend=qstart)) +
ggplot2::coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")
bitlocus = matrix(0, length(gridlines), length(gridlines))
# Fill the bitlocus. Naive approach.
for (i in 1:length(gridlines)){
for j in 1:length(gridlines)){
}
}
plot + ggplot2::xlim(c(0,10000)) + ggplot2::ylim(c(0,10000)) +
ggplot2::geom_hline(yintercept=gridlines_y) +
ggplot2::geom_vline(xintercept=gridlines_x)
gridlines_x
girdlines
gridlines = sort(unique(c(gridlines_x, gridlines_y)))
gridlines
grid = matrix(0, length(gridlines), length_gridlines)
grid = matrix(0, length(gridlines), length(gridlines))
grid
gridlines
grid
paf
# Fill the bitlocus. Naive approach.
for (x in 1:length(gridlines)){
x_idx = x_idx + 1
y_idx = 0
for (y in 1:length(gridlines)){
y_idx = yidx + 1
if((x %in% paf$tstart) & (y %in% paf$qstart)){
grid[x_idx, y_idx] = 1
}
}
}
# Fill the bitlocus. Naive approach.
x_idx = 0
y_idx = 0
for (x in 1:length(gridlines)){
x_idx = x_idx + 1
y_idx = 0
for (y in 1:length(gridlines)){
y_idx = yidx + 1
if((x %in% paf$tstart) & (y %in% paf$qstart)){
grid[x_idx, y_idx] = 1
}
}
}
# Fill the bitlocus. Naive approach.
x_idx = 0
y_idx = 0
for (x in 1:length(gridlines)){
x_idx = x_idx + 1
y_idx = 0
for (y in 1:length(gridlines)){
y_idx = y_idx + 1
if((x %in% paf$tstart) & (y %in% paf$qstart)){
grid[x_idx, y_idx] = 1
}
}
}
grid
heatmap(grid)
print(x)
for (x in 1:length(gridlines)){
x_idx = x_idx + 1
y_idx = 0
for (y in 1:length(gridlines)){
y_idx = y_idx + 1
print(x)
if((x %in% paf$tstart) & (y %in% paf$qstart)){
grid[x_idx, y_idx] = 1
}
}
}
gridlines[2]
# Fill the bitlocus. Naive approach.
for (x in 1:length(gridlines)){
for (y in 1:length(gridlines)){
if((gridlines[x] %in% paf$tstart) & (gridlines[y] %in% paf$qstart)){
grid[x, y] = 1
}
}
}
heatmap(grid)
grid
grid = matrix(0, length(gridlines), length(gridlines))
# Fill the bitlocus. Naive approach.
for (x in 1:length(gridlines)){
for (y in 1:length(gridlines)){
#if((gridlines[x] %in% paf$tstart) & (gridlines[y] %in% paf$qstart)){
if (c(gridlines[x], gridlines[y]) %in% paf[,c('tstart','qstart')])
grid[x, y] = 1
}
}
sum(grid)
grid
x = 4
y = 4
y = 7
c(gridlines[x], gridlines[y])
paf[,c('tstart','qstart')]
paf
x = 2
y = 1
gridlines[1]
c(gridlines[x], gridlines[y])
grid = matrix(0, length(gridlines), length(gridlines))
# Fill the bitlocus. Naive approach.
for (x in 1:length(gridlines)){
for (y in 1:length(gridlines)){
#if((gridlines[x] %in% paf$tstart) & (gridlines[y] %in% paf$qstart)){
#print()
if (c(gridlines[x], gridlines[y]) %in% paf[,c('qstart','tstart')])
grid[x, y] = 1
}
}
grid
sum(grid)
c(gridlines[x], gridlines[y])
x=2
y =1
c(gridlines[x], gridlines[y])
paf
paf[,c('tstart','qstart')]
c(1000,0) %in% paf[,c('tstart','qstart')]
nrow(merge(rc(1000,0),paf[,c('tstart','qstart')]))>0
paf[,c('tstart','qstart')]
merge(c(1000,0),paf[,c('tstart','qstart')])
any(paf$tstart == 1000 & paf$qstart == 0)
gridlines = sort(unique(c(gridlines_x, gridlines_y)))
grid = matrix(0, length(gridlines), length(gridlines))
grid
sum(grid)
gridlines = sort(unique(c(gridlines_x, gridlines_y)))
grid = matrix(0, length(gridlines), length(gridlines))
# Fill the bitlocus. Naive approach.
for (x in 1:length(gridlines)){
for (y in 1:length(gridlines)){
#if((gridlines[x] %in% paf$tstart) & (gridlines[y] %in% paf$qstart)){
#print()
if any(paf$tstart == gridlines[x] & paf$qstart == gridlines[y])
grid[x, y] = 1
}
}
gridlines = sort(unique(c(gridlines_x, gridlines_y)))
grid = matrix(0, length(gridlines), length(gridlines))
# Fill the bitlocus. Naive approach.
for (x in 1:length(gridlines)){
for (y in 1:length(gridlines)){
#if((gridlines[x] %in% paf$tstart) & (gridlines[y] %in% paf$qstart)){
#print()
if any(paf$tstart == gridlines[x] & paf$qstart == gridlines[y]){
grid[x, y] = 1
}
}
}
gridlines = sort(unique(c(gridlines_x, gridlines_y)))
grid = matrix(0, length(gridlines), length(gridlines))
# Fill the bitlocus. Naive approach.
for (x in 1:length(gridlines)){
for (y in 1:length(gridlines)){
#if((gridlines[x] %in% paf$tstart) & (gridlines[y] %in% paf$qstart)){
#print()
if (any(paf$tstart == gridlines[x] & paf$qstart == gridlines[y])){
grid[x, y] = 1
}
}
}
grid
sum(grid)
gridlines = sort(unique(c(gridlines_x, gridlines_y)))
grid = matrix(0, length(gridlines), length(gridlines))
# Fill the bitlocus. Naive approach.
for (y in 1:length(gridlines)){
#if((gridlines[x] %in% paf$tstart) & (gridlines[y] %in% paf$qstart)){
#print()
if (any(paf$tstart == gridlines[x] & paf$qstart == gridlines[y])){
grid[x, y] = 1
if (any(paf$tstart == gridlines[x+1] & paf$qstart == gridlines[y+1])){
grid[x, y] = -1
}
}
}
gridlines = sort(unique(c(gridlines_x, gridlines_y)))
grid = matrix(0, length(gridlines), length(gridlines))
# Fill the bitlocus. Naive approach.
for (x in 1:length(gridlines)){
for (y in 1:length(gridlines)){
#if((gridlines[x] %in% paf$tstart) & (gridlines[y] %in% paf$qstart)){
#print()
if (any(paf$tstart == gridlines[x] & paf$qstart == gridlines[y])){
grid[x, y] = 1
}
if (any(paf$tstart == gridlines[x+1] & paf$qstart == gridlines[y+1])){
grid[x, y] = -1
}
}
}
