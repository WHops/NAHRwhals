sds = seq_sds[[2]]
} else {
stop(paste0("Unknown mutation type: ",  svs[n_sv,]$SV))
}
}
writeFasta(data.frame(name='sim-sequence-mutated', seq=seq),
filename=outfasta)
write.table(sds, file=outsd, sep='\t', col.names=F, row.names = F, quote = F)
print('Success! Mutated sequence and sd written.')
}
seq_sds = carry_out_inv(seq, sds, svs[n_sv,])
n_sv
sv
svs
seq_sds = carry_out_del(seq, sds, svs[n_sv,])
seq = seq_sds[[1]]
sds = seq_sds[[2]]
sds
sds_bu
sds_m1 = sds
n_sv = 2
seq_sds = carry_out_inv(seq, sds, svs[n_sv,])
seq = seq_sds[[1]]
sds = seq_sds[[2]]
sds
setwd("~/PhD/projects/nahrcall/nahrchainer/seqbuilder/R")
## Make Dot Plot with Percent Divergence on color scale
suppressPackageStartupMessages(library(optparse))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(plotly))
# Turn paf to SD bed
paf_write_bed <- function(inpaf_link, outsdbed_link){
paf_sd = paf_to_sd_paf(inpaf_link)
bed_sd = paf_to_bed(paf_sd)
write.table(bed_sd, outsdbed_link, sep='\t', col.names=F, row.names=F, quote=F)
}
# Filter paf to sd relevant entries
paf_to_sd_paf <- function(inpaf_link){
inpaf = read.table(inpaf_link, sep='\t')
colnames_paf = c('qname','qlen','qstart','qend',
'strand','tname','tlen','tstart',
'tend','nmatch','alen','mapq')
colnames(inpaf)[1:length(colnames_paf)] = colnames_paf
# For safety: sort entries by qstart
inpaf = inpaf[order(inpaf$qstart),]
paf_sd = inpaf[(
(inpaf$qstart != inpaf$tstart) &
(inpaf$qend != inpaf$tend) &
(inpaf$qstart < inpaf$tstart)
),]
return(paf_sd)
}
# Convert to bed
paf_to_bed <- function(inpaf){
# In case colnames are not yet there
colnames_paf = c('qname','qlen','qstart','qend',
'strand','tname','tlen','tstart',
'tend','nmatch','alen','mapq')
colnames(inpaf)[1:length(colnames_paf)] = colnames_paf
inpaf$id = inpaf$nmatch / inpaf$alen
bed_sd = inpaf[,c('qname','qstart','qend','qname','qname', 'tstart','tend','strand','id')]
bed_sd$qname = sub("_.*","", inpaf$qname)
bed_sd$qname.2 = sub("_.*","", inpaf$qname)
return(bed_sd)
}
opt=list()
opt$min_query_aln = 0
opt$min_align = 0
opt$on_target = T
opt$input_filename = '/Users/hoeps/PhD/projects/nahrcall/nahrchainer/seqbuilder/res/paf/invs_mut_self.paf'
# read in alignments
alignments = read.table(opt$input_filename, stringsAsFactors = F, fill = T, row.names=NULL, comment.char='')
# read in originvbed
#originv = read.table(opt$originvbed, stringsAsFactors = F)
#colnames(originv) = c('chrom','start','end')
# set column names
# PAF IS ZERO-BASED - CHECK HOW CODE WORKS
colnames(alignments)[1:12] = c("queryID","queryLen","queryStart","queryEnd","strand","refID","refLen","refStart","refEnd","numResidueMatches","lenAln","mapQ")
# Fixes for PAF
# Some measure of similarity - need to check on this
alignments$percentID = alignments$numResidueMatches / alignments$lenAln
queryStartTemp = alignments$queryStart
# Flip starts, ends for negative strand alignments
alignments$queryStart[which(alignments$strand == "-")] = alignments$queryEnd[which(alignments$strand == "-")]
alignments$queryEnd[which(alignments$strand == "-")] = queryStartTemp[which(alignments$strand == "-")]
rm(queryStartTemp)
cat(paste0("\nNumber of alignments: ", nrow(alignments),"\n"))
cat(paste0("Number of query sequences: ", length(unique(alignments$queryID)),"\n"))
# sort by ref chromosome sizes, keep top X chromosomes OR keep specified IDs
if(is.null(opt$refIDs)){
chromMax = tapply(alignments$refEnd, alignments$refID, max)
if(is.null(opt$keep_ref)){
opt$keep_ref = length(chromMax)
}
refIDsToKeepOrdered = names(sort(chromMax, decreasing = T)[1:opt$keep_ref])
alignments = alignments[which(alignments$refID %in% refIDsToKeepOrdered),]
} else {
refIDsToKeepOrdered = unlist(strsplit(opt$refIDs, ","))
alignments = alignments[which(alignments$refID %in% refIDsToKeepOrdered),]
}
# filter queries by alignment length, for now include overlapping intervals
queryLenAgg = tapply(alignments$lenAln, alignments$queryID, sum)
alignments = alignments[which(alignments$queryID %in% names(queryLenAgg)[which(queryLenAgg > opt$min_query_aln)]),]
# filter alignment by length
alignments = alignments[which(alignments$lenAln > opt$min_align),]
# re-filter queries by alignment length, for now include overlapping intervals
queryLenAgg = tapply(alignments$lenAln, alignments$queryID, sum)
alignments = alignments[which(alignments$queryID %in% names(queryLenAgg)[which(queryLenAgg > opt$min_query_aln)]),]
cat(paste0("\nAfter filtering... Number of alignments: ", nrow(alignments),"\n"))
cat(paste0("After filtering... Number of query sequences: ", length(unique(alignments$queryID)),"\n\n"))
# sort df on ref
alignments$refID = factor(alignments$refID, levels = refIDsToKeepOrdered) # set order of refID
alignments = alignments[with(alignments,order(refID,refStart)),]
chromMax = tapply(alignments$refEnd, alignments$refID, max)
# make new ref alignments for dot plot
if(length(levels(alignments$refID)) > 1){
alignments$refStart2 = alignments$refStart + sapply(as.character(alignments$refID), function(x) ifelse(x == names((chromMax))[1], 0, cumsum(as.numeric(chromMax))[match(x, names(chromMax)) - 1]) )
alignments$refEnd2 = alignments$refEnd +     sapply(as.character(alignments$refID), function(x) ifelse(x == names((chromMax))[1], 0, cumsum(as.numeric(chromMax))[match(x, names(chromMax)) - 1]) )
} else {
alignments$refStart2 = alignments$refStart
alignments$refEnd2 = alignments$refEnd
}
## queryID sorting step 1/2
# sort levels of factor 'queryID' based on longest alignment
alignments$queryID = factor(alignments$queryID, levels=unique(as.character(alignments$queryID)))
queryMaxAlnIndex = tapply(alignments$lenAln,
alignments$queryID,
which.max,
simplify = F)
alignments$queryID = factor(alignments$queryID, levels = unique(as.character(alignments$queryID))[order(mapply(
function(x, i)
alignments$refStart2[which(i == alignments$queryID)][x],
queryMaxAlnIndex,
names(queryMaxAlnIndex)
))])
## queryID sorting step 2/2
## sort levels of factor 'queryID' based on longest aggregrate alignmentst to refID's
# per query ID, get aggregrate alignment length to each refID
queryLenAggPerRef = sapply((levels(alignments$queryID)), function(x) tapply(alignments$lenAln[which(alignments$queryID == x)], alignments$refID[which(alignments$queryID == x)], sum) )
if(length(levels(alignments$refID)) > 1){
queryID_Ref = apply(queryLenAggPerRef, 2, function(x) rownames(queryLenAggPerRef)[which.max(x)])
} else {queryID_Ref = sapply(queryLenAggPerRef, function(x) names(queryLenAggPerRef)[which.max(x)])}
# set order for queryID
alignments$queryID = factor(alignments$queryID, levels = (levels(alignments$queryID))[order(match(queryID_Ref, levels(alignments$refID)))])
# get mean percent ID per contig
#   calc percent ID based on on-target alignments only
if(opt$on_target & length(levels(alignments$refID)) > 1){
alignments$queryTarget = queryID_Ref[match(as.character(alignments$queryID), names(queryID_Ref))]
alignmentsOnTarget = alignments[which(as.character(alignments$refID) == alignments$queryTarget),]
scaffoldIDmean = tapply(alignmentsOnTarget$percentID, alignmentsOnTarget$queryID, mean)
alignments$percentIDmean = as.numeric(scaffoldIDmean[match(as.character(alignments$queryID), names(scaffoldIDmean))])
alignments$percentIDmean[which(as.character(alignments$refID) != alignments$queryTarget)] = NA
} else{
scaffoldIDmean = tapply(alignments$percentID, alignments$queryID, mean)
alignments$percentIDmean = as.numeric(scaffoldIDmean[match(as.character(alignments$queryID), names(scaffoldIDmean))])
}
# plot
yTickMarks = tapply(alignments$queryEnd, alignments$queryID, max)
options(warn = -1) # turn off warnings
gp = ggplot(alignments) +
#geom_point(mapping = aes(y = refStart2, x = queryStart2),
#           size = 0.009) +
#geom_point(mapping = aes(y = refEnd2, x = queryEnd2),
#           size = 0.009) +
geom_segment(aes(
y = queryStart,
yend = queryEnd,
x = refStart,
xend = refEnd,
color = percentID,#sign(queryEnd-queryStart),
text = sprintf(
'Query ID: %s<br>Query Start Pos: %s<br>Query End Pos: %s<br>Target ID: %s<br>Target Start Pos: %s<br>Target End Pos: %s<br>Length: %s kb',
queryID,
queryStart,
queryEnd,
refID,
refStart,
refEnd,
round(lenAln / 1000, 1)
)
)) +
# geom_rect(inherit.aes=FALSE, aes(xmin=200000, xmax=200000+(originv$end-originv$start), ymin=0,
#            ymax=max(refEnd2)), color="transparent", fill="orange", alpha=0.05) +
#geom_rect(inherit.aes=FALSE, aes(xmin=200000, xmax=200000+(originv$end-originv$start), ymin=0,
#             ymax=max(refEnd2)), color="transparent", fill="orange", alpha=0.002) +
#scale_x_continuous(breaks = cumsum(chromMax),
#                   labels = levels(alignments$refID)) +
#theme_bw() +
#theme(text = element_text(size = 8)) +
#theme(
#  panel.grid.major.y = element_blank(),
#  panel.grid.minor.y = element_blank(),
#  panel.grid.minor.x = element_blank(),
#  axis.text.y = element_text(size = 4, angle = 15)
#) +
#scale_y_continuous(breaks = yTickMarks, labels = substr(levels(alignments$queryID), start = 1, stop = 20)) +
#{ if(opt$h_lines){ geom_hline(yintercept = yTickMarks,
#                              color = "grey60",
#                              size = .1) }} +
labs(color = "Percent ID",
title = opt$input_filename) +
xlab(as.character(alignments$refID[1])) +
ylab(as.character(alignments$queryID[1])) +
scale_x_continuous(labels = scales::comma) +
scale_y_continuous(labels = scales::comma) +
coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on") +
theme_bw()
gp
sdfile
sdlink = '/Users/hoeps/PhD/projects/nahrcall/nahrchainer/seqbuilder/res/fa/invs_mut.bed'
sdfile = read.table(sdlink, sep='\t')
sd_simple = sd_to_bed(sdfile)
#!/usr/local/bin/Rscript
# Functions
sd_to_bed <- function(sdlink, outbedfile, return=F){
library(dplyr)
sd = read.table(sdlink, sep='\t')
colnames(sd) =  c(
"chrom", "chromStart", "chromEnd", "name",
"score","strand", "otherChrom","otherStart", "otherEnd",
"otherSize", "uid", "posBasesHit", "testResult",
"verdict", "chits","ccov","alignfile","alignL","indelN",
"indelS","alignB","matchB","mismatchB", "transitionsB",
"transversionsB","fracMatch","fracMatchIndel","jcK", "k2K"
)
sd_keep = sd[,c('chrom','chromStart','chromEnd', 'uid',
'otherChrom', 'otherStart', 'otherEnd',
'strand', 'fracMatch')]
print(sd_keep)
sd_keep_uniq = sd_keep %>% group_by(uid) %>% slice(1)
sd_keep_uniq_sort = sd_keep_uniq[order(sd_keep_uniq$chromStart),]
if (return){
return(sd_keep_uniq_sort)
} else if (return==F){
write.table(sd_keep_uniq_sort, file=outbedfile, sep='\t', row.names=F, col.names=F, quote=F)
}
}
#!/usr/local/bin/Rscript
# Functions
sd_to_bed <- function(sdlink, outbedfile=NULL){
library(dplyr)
sd = read.table(sdlink, sep='\t')
colnames(sd) =  c(
"chrom", "chromStart", "chromEnd", "name",
"score","strand", "otherChrom","otherStart", "otherEnd",
"otherSize", "uid", "posBasesHit", "testResult",
"verdict", "chits","ccov","alignfile","alignL","indelN",
"indelS","alignB","matchB","mismatchB", "transitionsB",
"transversionsB","fracMatch","fracMatchIndel","jcK", "k2K"
)
sd_keep = sd[,c('chrom','chromStart','chromEnd', 'uid',
'otherChrom', 'otherStart', 'otherEnd',
'strand', 'fracMatch')]
print(sd_keep)
sd_keep_uniq = sd_keep %>% group_by(uid) %>% slice(1)
sd_keep_uniq_sort = sd_keep_uniq[order(sd_keep_uniq$chromStart),]
if (is.null(outbedfile)){
return(sd_keep_uniq_sort)
} else if ( !is.null(outbedfile) ){
write.table(sd_keep_uniq_sort, file=outbedfile, sep='\t', row.names=F, col.names=F, quote=F)
}
}
sdlink = '/Users/hoeps/PhD/projects/nahrcall/nahrchainer/seqbuilder/res/fa/invs_mut.bed'
sdfile = read.table(sdlink, sep='\t')
sd_simple = sd_to_bed(sdfile)
sd_simple = sd_to_bed(sdlink)
sd_to_bed <- function(sdlink, outbedfile=NULL){
library(dplyr)
sd = read.table(sdlink, sep='\t')
colnames(sd) =  c(
"chrom", "chromStart", "chromEnd", "name",
"score","strand", "otherChrom","otherStart", "otherEnd",
"otherSize", "uid", "posBasesHit", "testResult",
"verdict", "chits","ccov","alignfile","alignL","indelN",
"indelS","alignB","matchB","mismatchB", "transitionsB",
"transversionsB","fracMatch","fracMatchIndel","jcK", "k2K"
)
sd_keep = sd[,c('chrom','chromStart','chromEnd', 'uid',
'otherChrom', 'otherStart', 'otherEnd',
'strand', 'fracMatch')]
print(sd_keep)
sd_keep_uniq = sd_keep %>% group_by(uid) %>% slice(1)
sd_keep_uniq_sort = sd_keep_uniq[order(sd_keep_uniq$chromStart),]
if (is.null(outbedfile)){
return(sd_keep_uniq_sort)
} else if ( !is.null(outbedfile) ){
write.table(sd_keep_uniq_sort, file=outbedfile, sep='\t', row.names=F, col.names=F, quote=F)
}
}
sd_simple = sd_to_bed(sdlink)
sd_simple
gp = gp + geom_highlight(data=sd_simple, aes(xstart=chromStart, xend=chromEnd))
?geom_rect
gp = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd))
gp
gp = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd))
gp
gp = ggplot(alignments) +
#geom_point(mapping = aes(y = refStart2, x = queryStart2),
#           size = 0.009) +
#geom_point(mapping = aes(y = refEnd2, x = queryEnd2),
#           size = 0.009) +
geom_segment(aes(
y = queryStart,
yend = queryEnd,
x = refStart,
xend = refEnd,
color = percentID,#sign(queryEnd-queryStart),
text = sprintf(
'Query ID: %s<br>Query Start Pos: %s<br>Query End Pos: %s<br>Target ID: %s<br>Target Start Pos: %s<br>Target End Pos: %s<br>Length: %s kb',
queryID,
queryStart,
queryEnd,
refID,
refStart,
refEnd,
round(lenAln / 1000, 1)
)
)) +
# geom_rect(inherit.aes=FALSE, aes(xmin=200000, xmax=200000+(originv$end-originv$start), ymin=0,
#            ymax=max(refEnd2)), color="transparent", fill="orange", alpha=0.05) +
#geom_rect(inherit.aes=FALSE, aes(xmin=200000, xmax=200000+(originv$end-originv$start), ymin=0,
#             ymax=max(refEnd2)), color="transparent", fill="orange", alpha=0.002) +
#scale_x_continuous(breaks = cumsum(chromMax),
#                   labels = levels(alignments$refID)) +
#theme_bw() +
#theme(text = element_text(size = 8)) +
#theme(
#  panel.grid.major.y = element_blank(),
#  panel.grid.minor.y = element_blank(),
#  panel.grid.minor.x = element_blank(),
#  axis.text.y = element_text(size = 4, angle = 15)
#) +
#scale_y_continuous(breaks = yTickMarks, labels = substr(levels(alignments$queryID), start = 1, stop = 20)) +
#{ if(opt$h_lines){ geom_hline(yintercept = yTickMarks,
#                              color = "grey60",
#                              size = .1) }} +
labs(color = "Percent ID",
title = opt$input_filename) +
xlab(as.character(alignments$refID[1])) +
ylab(as.character(alignments$queryID[1])) +
scale_x_continuous(labels = scales::comma) +
scale_y_continuous(labels = scales::comma) +
coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on") +
theme_bw()
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd))
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.5, color='orange')
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.5, fill='orange')
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.2, fill='orange')
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='orange')
gp2
alignments
gp2
gp
sd_simple
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='orange') +
geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=chromStart/2, ymax=chromEnd/2),
alpha=0.25, fill='orange')
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='orange') +
geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=chromStart/2, ymax=chromEnd),
alpha=0.25, fill='orange')
gp2
gp2
gp
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='orange') +
geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=chromStart, ymax=otherEnd),
alpha=0.25, fill='orange')
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='orange') +
geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=chromStart, ymax=otherEnd),
alpha=0.25, fill='grey')
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='orange') +
geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=chromStart, ymax=otherEnd),
alpha=0.25, fill='grey') +
geom_rect(data=sd_simple, aes(xmin=otherStart, xmax=chromEnd,
ymin=chromStart, ymax=chromEnd),
alpha=0.25, fill='grey')
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='orange') +
geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=chromStart, ymax=otherEnd),
alpha=0.25, fill='grey') +
geom_rect(data=sd_simple, aes(xmin=otherStart, xmax=otherEnd,
ymin=chromStart, ymax=chromEnd),
alpha=0.25, fill='grey')
gp2
gp2 = gp + geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='orange') +
geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=chromEnd,
ymin=chromStart, ymax=otherEnd),
alpha=0.25, fill='grey') +
geom_rect(data=sd_simple, aes(xmin=chromStart, xmax=otherEnd,
ymin=otherStart, ymax=otherEnd),
alpha=0.25, fill='grey')
gp2
outfasta = "/Users/hoeps/PhD/projects/nahrcall/nahrchainer/seqbuilder/data/examples/TPSAB1.fa"
outplot2
outfasta = "/Users/hoeps/PhD/projects/nahrcall/nahrchainer/seqbuilder/data/examples/TPSAB1.fa"
outpaf = './blub.paf'
outplo2 = 'TPSAB1.pdf'
# Make minimap2 alignment
make_chunked_minimap_alnment(outfasta, outfasta, outpaf, outplot2, chunklen = chunklen)
suppressMessages(source_here('seqbuilder.R'))
suppressMessages(source_here('seqbuilder_functions.R'))
suppressMessages(source_here('seqplotter.R'))
suppressMessages(source_here('pafCoordsDotPlotly.R'))
suppressMessages(source_here('seqmodder.R'))
suppressMessages(source_here('compress_paf.R'))
suppressMessages(source_here('paf_to_bed.R'))
suppressMessages(source_here('sd_to_bed.R'))
source_here <- function(x, ...) {
dir <- "."
if(sys.nframe()>0) {
frame <- sys.frame(1)
if (!is.null(frame$ofile)) {
dir <- dirname(frame$ofile)
}
}
source(file.path(dir, x), ...)
}
suppressMessages(source_here('seqbuilder.R'))
suppressMessages(source_here('seqbuilder_functions.R'))
suppressMessages(source_here('seqplotter.R'))
suppressMessages(source_here('pafCoordsDotPlotly.R'))
suppressMessages(source_here('seqmodder.R'))
suppressMessages(source_here('compress_paf.R'))
suppressMessages(source_here('paf_to_bed.R'))
suppressMessages(source_here('sd_to_bed.R'))
outfasta = "/Users/hoeps/PhD/projects/nahrcall/nahrchainer/seqbuilder/data/examples/TPSAB1.fa"
outpaf = './blub.paf'
outplo2 = 'TPSAB1.pdf'
outplot2 = 'TPSAB1.pdf'
# Make minimap2 alignment
make_chunked_minimap_alnment(outfasta, outfasta, outpaf, outplot2, chunklen = chunklen)
chunklen = 500
# Make minimap2 alignment
make_chunked_minimap_alnment(outfasta, outfasta, outpaf, outplot2, chunklen = chunklen)
a = 1:10
a * 500
a * 500 * 3
a = 0:10
a
b = a * 500 * 3
b
b = a * 500 * 2
a
b
start = (0:n_sds) * ((opt$sdlen * 3) + opt$dist)
opt$seqlen = 10000
opt$distance = 100
opt$sdlen = 500
n_sds = opt$seqlen / ((opt$sdlen*3) + opt$distance)
n_ds
n_sds
floor(n_sds)
n_sds = floor(opt$seqlen / ((opt$sdlen*3) + opt$distance))
0:6
start = (0:n_sds-1) * ((opt$sdlen * 3) + opt$dist)
start
start = (0:(n_sds-1)) * ((opt$sdlen * 3) + opt$dist)
start
opt$inter_sd_len = 500
chromStart = (0:(n_sds-1)) * ((opt$sdlen * 2) + opt$inter_sd_len + opt$dist)
chromEnd = chromStart + opt$sdlen
otherStart = chromEnd + opt$inter_sd_len
otherEnd = otherStart + opt$sdlen
chromStart
chromEnd
otherStart
otherEnd
sds_raw = data.frame('chrom' = contig,
'chromStart' = chromStart)
contig = "simcontig"
sds_raw = data.frame('chrom' = contig,
'chromStart' = chromStart)
sds_raw
uid = paste0("SD", 1:n_sds)
uid
