% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fasta_extraction_functions.R
\name{find_punctual_liftover}
\alias{find_punctual_liftover}
\title{liftover_coarse
liftover_coarse <-
function(seqname,
start,
end,
conversionpaf_link,
factor = 0.5) {
start = 74769950
end = 76058098\preformatted{start = 75000001
end = 75010001
cpaf = read.table(
  conversionpaf_link,
  sep = '\\t',
  fill = T,
  row.names = NULL
)

colnames_paf = c(
  'qname',
  'qlen',
  'qstart',
  'qend',
  'strand',
  'tname',
  'tlen',
  'tstart',
  'tend',
  'nmatch',
  'alen',
  'mapq'
)
colnames(cpaf)[1:length(colnames_paf)] = colnames_paf

# Query: from (..hg38..)
# Target: to ( ..assembly.. )

cpaf_i = cpaf[(cpaf$qname == seqname), ]


# Get alignments that
cpaf_intersect = cpaf_i[(cpaf_i$qend >= start) &
                          (cpaf_i$qstart <= end), ]

aln_containing = cpaf_i[(cpaf_i$qstart <= start) &
                          (cpaf_i$qend >= end), ]

# determine case
case = determine_case(cpaf_intersect, aln_containing)


# Start coord
alns_containing_my_start = cpaf_i[(cpaf_i$qend >= start) &
                                    (cpaf_i$qstart <= start), ]
longest_alns_containing_my_start = alns_containing_my_start[order(alns_containing_my_start$nmatch, decreasing =
                                                                    F), ][1, ]

# End coord
alns_containing_my_end = cpaf_i[(cpaf_i$qend >= end) &
                                  (cpaf_i$qstart <= end), ]
longest_aln_containing_my_end = alns_containing_my_end[order(alns_containing_my_end$nmatch, decreasing =
                                                               F), ][1, ]

if (longest_alns_containing_my_start$qname != longest_aln_containing_my_end$qname) \{
  if (longest_alns_containing_my_start$nmatch > longest_aln_containing_my_end$nmatch) \{
    longest_aln_containing_my_end = longest_alns_containing_my_start
  \} else \{
    longest_aln_containing_my_start = longest_alns_containing_my_end
  \}
\}


if (longest_alns_containing_my_start$strand == '+') \{
  liftover_start = longest_alns_containing_my_start$tstart + (start - longest_alns_containing_my_start$qstart)
\} else \{
  liftover_start = longest_alns_containing_my_start$tend - (start - longest_alns_containing_my_start$qstart)
\}



if (longest_aln_containing_my_end$strand == '+') \{
  liftover_end = longest_aln_containing_my_end$tend - (longest_aln_containing_my_end$qend - end)
\} else \{
  liftover_end = longest_aln_containing_my_end$tstart + (longest_aln_containing_my_end$qend - end)
\}


liftover_start_real = as.integer(min(liftover_start, liftover_end) - ((end -
                                                                         start) * factor))
liftover_end_real = as.integer(max(liftover_start, liftover_end) + ((end -
                                                                       start) * factor))


to_return = list(
  lift_contig = alns_containing_my_start$tname,
  lift_start = max(liftover_start_real, 0),
  lift_end = min(liftover_end_real, alns_containing_my_start$tlen)
)

return(to_return)
}

}}
\usage{
find_punctual_liftover(cpaf, pointcoordinate)
}
\description{
liftover_coarse
liftover_coarse <-
function(seqname,
start,
end,
conversionpaf_link,
factor = 0.5) {
start = 74769950
end = 76058098\preformatted{start = 75000001
end = 75010001
cpaf = read.table(
  conversionpaf_link,
  sep = '\\t',
  fill = T,
  row.names = NULL
)

colnames_paf = c(
  'qname',
  'qlen',
  'qstart',
  'qend',
  'strand',
  'tname',
  'tlen',
  'tstart',
  'tend',
  'nmatch',
  'alen',
  'mapq'
)
colnames(cpaf)[1:length(colnames_paf)] = colnames_paf

# Query: from (..hg38..)
# Target: to ( ..assembly.. )

cpaf_i = cpaf[(cpaf$qname == seqname), ]


# Get alignments that
cpaf_intersect = cpaf_i[(cpaf_i$qend >= start) &
                          (cpaf_i$qstart <= end), ]

aln_containing = cpaf_i[(cpaf_i$qstart <= start) &
                          (cpaf_i$qend >= end), ]

# determine case
case = determine_case(cpaf_intersect, aln_containing)


# Start coord
alns_containing_my_start = cpaf_i[(cpaf_i$qend >= start) &
                                    (cpaf_i$qstart <= start), ]
longest_alns_containing_my_start = alns_containing_my_start[order(alns_containing_my_start$nmatch, decreasing =
                                                                    F), ][1, ]

# End coord
alns_containing_my_end = cpaf_i[(cpaf_i$qend >= end) &
                                  (cpaf_i$qstart <= end), ]
longest_aln_containing_my_end = alns_containing_my_end[order(alns_containing_my_end$nmatch, decreasing =
                                                               F), ][1, ]

if (longest_alns_containing_my_start$qname != longest_aln_containing_my_end$qname) \{
  if (longest_alns_containing_my_start$nmatch > longest_aln_containing_my_end$nmatch) \{
    longest_aln_containing_my_end = longest_alns_containing_my_start
  \} else \{
    longest_aln_containing_my_start = longest_alns_containing_my_end
  \}
\}


if (longest_alns_containing_my_start$strand == '+') \{
  liftover_start = longest_alns_containing_my_start$tstart + (start - longest_alns_containing_my_start$qstart)
\} else \{
  liftover_start = longest_alns_containing_my_start$tend - (start - longest_alns_containing_my_start$qstart)
\}



if (longest_aln_containing_my_end$strand == '+') \{
  liftover_end = longest_aln_containing_my_end$tend - (longest_aln_containing_my_end$qend - end)
\} else \{
  liftover_end = longest_aln_containing_my_end$tstart + (longest_aln_containing_my_end$qend - end)
\}


liftover_start_real = as.integer(min(liftover_start, liftover_end) - ((end -
                                                                         start) * factor))
liftover_end_real = as.integer(max(liftover_start, liftover_end) + ((end -
                                                                       start) * factor))


to_return = list(
  lift_contig = alns_containing_my_start$tname,
  lift_start = max(liftover_start_real, 0),
  lift_end = min(liftover_end_real, alns_containing_my_start$tlen)
)

return(to_return)
}

}
}
