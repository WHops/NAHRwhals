using ArgParse
using DelimitedFiles
using ProgressMeter

"""
    Moveset(duplicate_delete, invert)

Struct containing possible duplications, deletions and inversions
in a compressed alignment.
"""
mutable struct Moveset
    duplicate_delete::Array{Bool, 2}
    invert::Array{Bool, 2}
end


"""
    PossibleMove(duplicate_delete::Bool, invert::Bool)

Possible move at a given pair of positions in a compressed alignment.
Specifies whether duplications, deletions or inversions are possible
between a pair of positions.
"""
struct PossibleMove
    duplicate_delete::Bool
    invert::Bool
end

"""
    MoveKind

Enum of possible move types.
"""
@enum MoveKind move_dup move_del move_inv move_null

"""
    MoveTaken(kind::MoveKind, start::Int64, stop::Int64)

Describes a move taken between two positions in a compressed alignment.
`kind` describes the type of move (duplication, deletion, inversion, no-op).
`start` specifies the start position of the move.
`stop` specifies the end position of the move.
"""
struct MoveTaken
    kind::MoveKind
    start::Int64
    stop::Int64
end

"""
    IndexStats(score::Float32, moves_into::Vector{MoveTaken})

Provides information on an index into a compressed alignment.
`score` specifies the score of the index in the range [0, 1],
    where 1 signifies perfect agreement with the target sequence.
`moves_into` provides a list of moves from other indices yielding this index.
"""
struct IndexStats
    score::Float32
    moves_into::Vector{MoveTaken}
end

"""
    IndexMap(...)

Provides information on all indices into a compressed alignment
generated by applying moves (deletions, duplications, inversions)
up to a fixed depth.
`map` is a map of indices into ids.
`indices` is an inverse map of ids into indices.
`parents` is a list of ids of indices which can yield
    a given index in a single move.
`scores` is a list of scores in [0, 1] for each index.
    A score of 1 indicates perfect agreement with the
    target sequence.
`moves` is a list of moves which can yield a given
    index from another index in the `IndexMap`.
`current` current maximum id in the `IndexMap`.
"""
mutable struct IndexMap
    map::Dict{Vector{Int16}, Int64}
    indices::Vector{Vector{Int16}}
    parents::Vector{Vector{Int64}}
    scores::Vector{Float32}
    moves::Vector{Vector{MoveTaken}}
    current::Int64
end

"""
    read_tsv(tsv_path::String)

Reads a TSV-file encoding a compressed alignment.
Arguments:
    `tsv_path`: the path to the TSV-file.
Returns:
    * a matrix containing the directionality of
      each block in a compressed alignment.
    * a vector containing the length of each
      block in a compressed alignment.
"""
function read_tsv(tsv_path::String)::Tuple{Array{Int8}, Array{Int64}}
    raw_data = readdlm(tsv_path, '\t', Float64, '\n')
    block_direction = sign.(raw_data)
    block_value = ceil.(log.(abs.(raw_data) .+ 1.0)) .* block_direction
    block_value = maximum(block_value; dims=1)
    transpose(block_direction), block_value
end

"""
    read_tsv(tsv_path::String)

Reads a TSV-file encoding a compressed alignment.
Arguments:
    `tsv_path`: the path to the TSV-file.
Returns:
    * a matrix containing the directionality of
      each block in a compressed alignment.
    * a vector containing the length of each
      block in a compressed alignment.
"""
function read_length_tsv(tsv_path::String)::Vector{Vector{Float64}}
    # Open the file
    open(tsv_path, "r") do file
        # Read lines from the file
        lines = readlines(file)

        # Check if there are exactly two lines (rows)
        if length(lines) != 2
            error("The TSV file must have exactly two rows.")
        end

        # Split each line by tabs and convert to Float64
        row1 = parse.(Float64, split(lines[1], '\t'))
        row2 = parse.(Float64, split(lines[2], '\t'))

        [row1, row2]
    end
end

# function read_length_tsv(tsv_path::String)::Array{Int64}
#     raw_data = readdlm(tsv_path, '\t', Float64, '\n'; skipstart = 1)
#     block_value = raw_data #ceil.(log.(abs.(raw_data) .+ 1.0)) #<- there was a 'log' here - why?
#     block_value
# end


"""
    compute_possible_moves(position_1::Array{Int8}, position_2::Array{Int8})::PossibleMove

Computes all possible moves between a pair of columns in a
compressed alignment.
Arguments:
    `position_1`: first column of a compressed alignment.
    `position_2`: second column of a compressed alignment.
Returns:
    `PossibleMove` containing information about the possible
    moves at the given pair of columns (deletion/duplication, inversion).
"""
function compute_possible_moves(position_1::Array{Int8}, position_2::Array{Int8})::PossibleMove
    product = position_1 .* position_2
    PossibleMove(
        any(product .== 1),
        any(product .==-1)
    )
end

"""
    retrieve_possible_moves(index, moveset, position_1, position_2)::PossibleMove

Computes possible moves between a pair of positions in a index into a compressed alignment,
given the index and a pre-computed set of possible moves for an alignment.
Arguments:
    `index`: an index into a compressed alignment.
    `moveset`: a precomputed set of moves for the alignment.
    `position_1`, `position_2`: two positions in the index.
Returns:
    `PossibleMoves` containing the possible moves between
    `position_1` and `position_2`.
"""
@inline function retrieve_possible_moves(index, moveset, position_1::Int, position_2::Int)::PossibleMove
    index_1 = index[position_1]
    index_2 = index[position_2]
    flip = index_1 * index_2 < 0
    dup_del = moveset.duplicate_delete[abs(index_1), abs(index_2)]
    inv = moveset.invert[abs(index_1), abs(index_2)]
    PossibleMove(
        (flip && inv) || (!flip && dup_del),
        (flip && dup_del) || (!flip && inv)
    )
end

"""
    movecount(moveset::Moveset)

Counts the total number of possible moves for a given Moveset.
Arguments:
    `moveset`: a pre-computed set of possible moves.
Returns:
    Number of moves.
"""
@inline function movecount(moveset::Moveset)::Int
    (2 * sum(moveset.duplicate_delete) + sum(moveset.invert)) // 2
end

"""
    to_moveset(aln)::Moveset

Pre-computes a `Moveset` from a compressed alignment.
Arguments:
    `aln`: compressed alignment in matrix form.
        Dimension 1 corresponds to reference positions.
        Dimension 2 corresponds to target positions.
Returns:
    `Moveset` containing all possible moves (deletions/duplications, inversions)
    for the input compressed alignment.
"""
function to_moveset(aln)::Moveset
    moveset_size = size(aln, 1)
    duplicate_delete = zeros(Bool, moveset_size, moveset_size)
    invert = zeros(Bool, moveset_size, moveset_size)
    @inbounds for i = 1:size(aln, 1)
        @inbounds for j = i + 1:size(aln, 1)
            possible_moves = compute_possible_moves(aln[i, :], aln[j, :])
            duplicate_delete[i, j] = possible_moves.duplicate_delete
            duplicate_delete[j, i] = possible_moves.duplicate_delete
            invert[i, j] = possible_moves.invert
            invert[j, i] = possible_moves.invert
        end
    end
    Moveset(duplicate_delete, invert)
end

"""
    apply_duplication(data, position_1, position_2)

Duplicates `data` between `position_1` and `position_2`.
Arguments:
    `data`: an index into a compressed alignment.
    `position_1`, `position_2`: start and end points for a duplication.
Returns:
    Index into a compressed alignment, including a duplication
    between `position_1` and `position_2`.
"""
@inline function apply_duplication(data::Array{T}, position_1::Int64, position_2::Int64)::Array{T} where {T}
    T[view(data, 1:position_2); view(data, position_1 + 1:size(data, 1))]
end

"""
    apply_deletion(data, position_1, position_2)

Deletes `data` between `position_1` and `position_2`.
Arguments:
    `data`: an index into a compressed alignment.
    `position_1`, `position_2`: start and end points for a deletion.
Returns:
    Index into a compressed alignment, including a deletion
    between `position_1` and `position_2`.
"""
@inline function apply_deletion(data::Array{T}, position_1::Int64, position_2::Int64)::Array{T} where {T}
    T[view(data, 1:position_1 - 1); view(data, position_2:size(data, 1))]
end

"""
    apply_inversion(data, position_1, position_2)

Inverts `data` between `position_1` and `position_2`.
Arguments:
    `data`: an index into a compressed alignment.
    `position_1`, `position_2`: start and end points for an inversion.
Returns:
    Index into a compressed alignment, including an inversion
    between `position_1` and `position_2`.
    Inverted positions are listed in reverse order and
    multiplied by -1.
"""
@inline function apply_inversion(data::Array{T}, position_1::Int64, position_2::Int64)::Array{T} where {T}
    T[view(data, 1:position_1); -view(data, position_2 - 1:-1:position_1 + 1); view(data, position_2:size(data, 1))]
end

"""
    duplication_count(index, max_size)

Counts the number of duplications contained in
an index into a compressed alignment.
Arguments:
    `index`: index into a compressed alignment.
    `max_size`: maximum value an index position can take.
        Corresponds to the length of the compressed reference sequence.
Returns:
    Number of duplications in `index`.
"""
function duplication_count(index, max_size)
    values = zeros(Int64, max_size)
    for i in 1:size(index, 1)
        values[abs(index[i])] += 1
    end
    maximum(values)
end




#######



"""
    slow_score(index, aln, lengths, max_offset)

Computes an agreement score for a given index into
a compressed alignment. 
This is a re-implementation by W. Hoeps, analogous to the original algorithm in 
NAHRwhals which was implemented in R. The way of scoring is inspired by the Needleman-Wunsch algorithm.
Since our squares are not symmetrical, we have a slight modification of the algorithm here. 
# The cost of traversing a square is: 
#   - The x-length of the field for traversing it in x-directionality
#   - The y-length of the field...... for y 
#   - 0 diagonally, if there is a positive alignment
#   - Inf diagonally, if there is no pos. alignment. 
Arguments:
    `index`: index into a compressed alignment.
    `aln`: compressed alignment.
    `lengths`: uncompressed lengths of compressed
        positions in `aln`.
Returns:
    Agreement score in [0, 1] between compressed reference and target.
    Score of 1 corresponds to perfect agreement.
"""
function slow_score(index, aln, lengths, forcecalc=1.0)

    # Easy exit for highly unsymmetrical results with are obviously nowhere near a correct solution
    if length(lengths[1]) > 10 && abs(length(index) - length(lengths[1])) > length(lengths[1]) * 0.5
        return 0.0
    end

    # Marry the index and aln to construct our mutated matrix 
    selected_rows = [idx < 0 ? -aln[-idx, :] : aln[idx, :] for idx in index]
    aln_to_use = hcat(selected_rows...)'

    row, col = size(aln_to_use)

    # The gap penalties are defined by the length values of the squares
    walk_right_cost = lengths[1]
    climb_up_cost = lengths[2][abs.(index)]
    
    cost_u = Float64.(repeat(climb_up_cost, 1, col))
    cost_r = Float64.(repeat(walk_right_cost', row, 1))

    cumsum_u = cumsum(climb_up_cost, dims=1)
    cumsum_r = cumsum(walk_right_cost, dims=1)

    cost_d =  Float64.(-aln_to_use)
    cost_d[cost_d .>= 0] .= Inf
    cost_d[cost_d .< 0] .= 0

    cost_res = zeros(Float64, row, col)

    # We will compute only a corridor in the middle to save time. Typically this is 0.2
    calc_corridor_pct = determine_corridor_pct(row, forcecalc)

    # Fill in the Scoring matrix
    cost_res[1, 1] = min(climb_up_cost[1] + walk_right_cost[1], cost_d[1, 1])

    fill_first_column!(cost_res, cost_u, cost_d, cumsum_u, calc_corridor_pct, row)
    fill_first_row!(cost_res, cost_r, cost_d, cumsum_r, calc_corridor_pct, col)

    # To be honest I'm not completely sure why we have to do this? 
    cost_res[2:row, 2:col] .= Inf

    fill_matrix!(cost_res, cost_d, cost_u, cost_r, calc_corridor_pct, row, col)

    total_cost = sum(vcat(climb_up_cost, walk_right_cost))

    round((1 - (cost_res[row, col]) / total_cost) * 100, digits=3)
    
end

function determine_corridor_pct(row, forcecalc)
    if row < 10
        1.0
    elseif row < 30
        0.3
    else
        0.2
    end #|> (pct -> forcecalc ? 1.0 : pct)
end

function fill_first_column!(cost_res, cost_u, cost_d, cumsum_u, calc_corridor_pct, row)
    for i in 2:row
        cost_res[i, 1] = if i / row > calc_corridor_pct
            Inf
        else
            min(cost_u[i, 1] + cost_res[i - 1, 1], cumsum_u[i - 1] + cost_d[i, 1])
        end
    end
end

function fill_first_row!(cost_res, cost_r, cost_d, cumsum_r, calc_corridor_pct, col)
    for j in 2:col
        cost_res[1, j] = if j / col > calc_corridor_pct
            Inf
        else
            min(cost_r[1, j] + cost_res[1, j - 1], cumsum_r[j - 1] + cost_d[1, j])
        end
    end
end

function fill_matrix!(cost_res, cost_d, cost_u, cost_r, calc_corridor_pct, row, col)
    i_mat = repeat((1:row) ./ row, 1, col)
    j_mat = repeat((1:col)' ./ col, row, 1)

    middleval_mat = 1 .- ((i_mat .> (j_mat .+ calc_corridor_pct)) .+ 
                          (j_mat .> (i_mat .+ calc_corridor_pct)))
    middleval_mat[1, :] .= 0
    middleval_mat[:, 1] .= 0
    idxs = findall(middleval_mat .== 1)

    for idx in idxs
        i, j = Tuple(idx)
        cost_res[i, j] = min(cost_res[i - 1, j - 1] + cost_d[i, j], 
                             cost_res[i - 1, j] + cost_u[i, j], 
                             cost_res[i, j - 1] + cost_r[i, j])
    end


end


#############










# function slow_score(index, aln, lengths, max_offset)
#     # approach:
#     # 1. index into the compressed alignment
#     # 2. follow the diagonal and assign a score of 1
#     #    for each on-diagonal positive orientation block
#     # 3. in case there is no on-diagonal positive block,
#     #    find the closest off-diagonal block and assign
#     #    a score of 1 / (distance-to-current-diagonal + 1)
#     # 4. update the diagonal to the one starting from
#     #    the closest off-diagonal block
#     # 5. repeat until the end of the index is reached
#     # 6. normalize the score by the total length of all blocks
#     #    + the number of unassigned blocks in the reference
#     score = 0
#     off_diagonal = 0
#     total_length = 0
#     print(aln, "\n")
#     print("index: ", index, "\n")

#     @simd for i in 1:size(index, 1)
#         print(index[i], "\n")
#         current_length = lengths[abs(index[i])]
#         score_update, off_diagonal = slow_score_kernel(
#             index, aln, i, off_diagonal, max_offset)
#         score += current_length * score_update
#         total_length += current_length
#     end
#     last_position = off_diagonal + size(index, 1)
#     last_length = lengths[abs(index[end])]
#     missing_length = last_length * abs(last_position - size(aln, 2))
#     print(lengths, "\n")
#     print("score: ", score, " total_length: ", total_length, " missing_length: ", missing_length, "\n")
#     score / (total_length + missing_length)
# end

# function slow_score_kernel(index, aln, i, off_diagonal, max_offset)
#     sgn = sign(index[i])
#     pos = abs(index[i])
#     new_off_diagonal = off_diagonal
#     best_dist = 10_000
#     # SIMD-friendly inner loop
#     # for each off-diagonal within 4 blocks
#     # of the current diagonal:
#     @simd for j in max(i + off_diagonal - max_offset, 1):min(i + off_diagonal + max_offset, size(aln, 2))
#         # compute the distance to the current diagonal
#         dist = abs(j - i - off_diagonal)
#         # check, if there's a positive-orientation block at that position
#         # and the distance to diagonal is the smallest seen so far
#         cond = sgn * aln[pos, j] > 0 && dist < best_dist
#         # if cond: set this off-diagonal as the new diagonal
#         # and set the current distance to this distance
#         new_off_diagonal = cond ? j - i : new_off_diagonal
#         best_dist = cond ? dist : best_dist
#     end

#     print("\n best_dist: ", best_dist, "\n")
#     # return a score of 1 / (distance + 1) and the position
#     # of the new diagonal
#     1 / (best_dist + 1), new_off_diagonal
# end

"""
    materialize_aln(index, aln)

Computes a compressed alignment corresponding to an index
into an existing compressed alignment.
Arguments:
    `index`: index into a compressed alignment.
    `aln`: compressed alignment.
Returns:
    New compressed alignment corresponding to the positions
    and orientations in `index`.
"""
function materialize_aln(index::Array{T}, aln) where {T}
    (sign.(index)) .* aln[abs.(index), :]
end

"""
    update_index!(...)

Updates an `IndexMap` with information for a new `index`.
Arguments:
    `index_map`: `IndexMap` containing index information.
    `indices`: `Vector` of indices in the current iteration of BFS.
    `index`: index for which to add information.
    `parent`: parent index of `index`.
    `move`: move (deletion, duplication, inversion) transforming `parent` into `index`.
    `aln`: compressed alignment.
    `lengths`: list of compressed alignment block lengths.
    `threshold`: heuristic score-threshold below which indices and moves are discarded.
    `best`: current highest score.
"""
@inline function update_index!(index_map, indices, index, parent, move, aln, lengths, threshold, best,
                               max_offset)
    # if the IndexMap has no entry for `index`:
    if !haskey(index_map.map, index)
        # compute the score of `index` & update
        # the current best score
        score = slow_score(index, aln, lengths, max_offset)
        if score > best
            best = score
        end

        # add an entry for `index` into the IndexMap
        index_map.map[index] = index_map.current + 1
        push!(index_map.indices, index)
        push!(index_map.parents, [index_map.map[parent]])
        push!(index_map.scores, score)
        push!(index_map.moves, [move])
        index_map.current += 1
        # heuristic cutoff to prune bad moves
        if score >= threshold
            push!(indices, index)
        end
    # otherwise:
    else
        # find the position of `index` in the IndexMap
        pos = index_map.map[index]
        # add new parent and move leading to `index`
        push!(index_map.parents[pos], index_map.map[parent])
        push!(index_map.moves[pos], move)
    end
    # return the current best score
    best
end

"""
    all_moves_scored(...)

Single step of BFS enumerating all moves (deletions, duplications, inversions)
originating at a single index.
Arguments:
    `index`: index into a compressed alignment.
    `movemap`: set of possible moves for `aln`.
    `aln`: compressed alignment.
    `lengths`: list of compressed alignment block lengths in `aln`.
    `best`: current highest score.
    `index_map`: `IndexMap` containing index information.
    `indices`: `Vector` of indices in the current iteration of BFS.
    `max_dup::Int64`: maximum number of duplications to consider
        for any given index.
    `suboptimality::Vector{Float64}`: percentage of previous
        highest score to use as a threshold for discarding
        bad moves.
Returns:
    Current highest score.
    Updates `index_map` with information about all indices
    reachable from `index` in a single move.
"""
function all_moves_scored!(index, movemap, aln, lengths, best,
                           index_map,
                           indices::Vector{Vector{T}},
                           max_dup::Int64,
                           suboptimality,
                           max_offset) where {T}
    start_score::Float32 = 0.0
    if haskey(index_map.map, index)
        start_score = index_map.scores[index_map.map[index]]
    else
        start_score = slow_score(index, aln, lengths, max_offset)
        index_map.map[index] = index_map.current + 1
        push!(index_map.parents, [])
        push!(index_map.scores, start_score)
        push!(index_map.moves, MoveTaken[])
        index_map.current += 1
    end
    current_best = best
    @inbounds for i = 1:size(index, 1)
        @inbounds for j = i + 1:size(index, 1)
            possible_moves = retrieve_possible_moves(index, movemap, i, j)
            if possible_moves.duplicate_delete
                if duplication_count(index, size(aln, 1)) <= max_dup
                    dup_index = apply_duplication(index, i, j)
                    move = MoveTaken(move_dup, i, j)
                    best = update_index!(
                        index_map, indices,
                        dup_index, index, move, aln, lengths,
                        suboptimality * current_best, best,
                        max_offset)
                end
                del_index = apply_deletion(index, i, j)
                move = MoveTaken(move_del, i, j)
                best = update_index!(
                    index_map, indices,
                    del_index, index, move, aln, lengths,
                    suboptimality * current_best, best,
                    max_offset
                )
            end
            if possible_moves.invert
                inv_index = apply_inversion(index, i, j)
                move = MoveTaken(move_inv, i, j)
                best = update_index!(
                    index_map, indices,
                    inv_index, index, move, aln, lengths,
                    suboptimality * current_best, best,
                    max_offset
                )
            end
        end
    end
    best
end

function aln_bfs_scored(aln, lengths; max_depth::Int = 3, max_dup::Int = 2,
                        max_offset::Int = 4,
                        suboptimality = nothing,
                        max_count = nothing,
                        silent = false)
    index_map = IndexMap(
        Dict{Array{Int16}, Int64}(),
        Vector{Int16}[],
        Vector{Int64}[],
        Float32[],
        MoveTaken[],
        0
    )
    moveset = to_moveset(aln)
    index = Int16[1:size(aln, 1);]
    indices = Vector{Int16}[]
    best = 0.0
    if !silent
        println("Iteration 1 with 1 index.")
    end
    best = all_moves_scored!(
        index, moveset, aln, lengths, best,
        index_map, indices, max_dup, 0.0, max_offset)
    @inbounds for depth = 1:max_depth-1
        subopt = !isnothing(suboptimality) ? suboptimality[depth] : 0.0
        if !isnothing(max_count)
            sort!(indices, by=x -> -index_map.scores[index_map.map[x]])
            indices = view(indices, 1:min(max_count, size(indices, 1)))
        end
        new_indices = Vector{Int16}[]
        if !silent
            println("Iteration ", depth + 1, " with ", length(indices), " indices.")
        end
        @showprogress for current_index in indices
            best = all_moves_scored!(
                current_index, moveset, aln,
                lengths, best, index_map, new_indices,
                max_dup, subopt, max_offset)
        end
        indices = new_indices
    end
    index_map, best
end

function concatenate_moves_aux(index_map, current_index, depth, maxdepth)
    if current_index == 1
        return Vector{MoveTaken}[[]], true
    elseif depth > maxdepth
        return Vector{MoveTaken}[[]], false
    end
    result = Vector{MoveTaken}[]
    valid = true
    for (parent, pmove) in Iterators.zip(index_map.parents[current_index], index_map.moves[current_index])
        (traj, valid) = concatenate_moves_aux(index_map, parent, depth + 1, maxdepth)
        if valid
            for t in traj
                push!(result, [t; pmove])
            end
        end
    end
    result, true
end

function index_to_trajectories(index_map, index, maxdepth)
    current_index = index_map.map[index]
    (traj, a) = concatenate_moves_aux(index_map, current_index, 0, maxdepth)
    traj
end

struct Trajectory
    score::Float32
    moves::Vector{MoveTaken}
end

function move_to_string(move::MoveTaken)::String
    "$(move.kind)\t$(move.start)\t$(move.stop)"
end

function trajectory_to_string(traj::Trajectory)::String
    ("$(traj.score)\t$(length(traj.moves))\t" *
     join([move_to_string(m) for m in traj.moves], "\t"))
end

function get_good_trajectories(index_map::IndexMap, best;
                               suboptimality=0.9, max_depth=3,
                               max_report = nothing)::Vector{Trajectory}
    trajectories = Trajectory[]
    for (index, key) = index_map.map
        score = index_map.scores[key]
        if score >= suboptimality * best
            for traj = index_to_trajectories(index_map, index, max_depth)
                push!(trajectories, Trajectory(score, traj))
            end
        end
    end
    sort!(trajectories, by=x -> (-x.score, length(x.moves)))
    if !isnothing(max_report)
        report_limit = min(max_report, length(trajectories))
        trajectories = view(trajectories, 1:report_limit)
    end
    trajectories
end

function write_trajectories(path::String, trajectories::Vector{Trajectory})
    open(path, "w") do f
        for traj = trajectories
            println(f, trajectory_to_string(traj))
        end
    end
end

function main()::Cint
    s = ArgParseSettings()
    @add_arg_table s begin
        "--maxdepth", "-d"
            help = "Maximum depth for breadth-first search."
            arg_type = Int64
            default = 3
        "--maxdup", "-u"
            help = "Maximum number of occurences for each position in the reference."
            arg_type = Int64
            default = 3
        "--maxwidth", "-w"
            help = "Maximum width for breadth-first search."
            arg_type = Int64
            default = nothing
        "--maxoffset", "-O"
            help = "Maximum off-diagonal jump in score function."
            arg_type = Int64
            default = 4
        "--minreport", "-r"
            help = "Threshold percentage of the best score for reporting."
            arg_type = Float64
            default = 0.95
        "--maxreport", "-R"
            help = "Maximum number of reported outputs."
            arg_type = Int64
            default = nothing
        "compressed_alignment"
            help = "Compressed alignment TSV file."
            required = true
        "compressed_lengths"
            help = "Compressed alignment block lengths TSV file."
            required = true
        "out_path"
            help = "Path to output TSV file."
            required = true
    end
    opt = parse_args(ARGS, s)
    aln, lengths = read_tsv(opt["compressed_alignment"])
    if isfile(opt["compressed_lengths"])
        lengths = read_length_tsv(opt["compressed_lengths"])
    end
    # precompile
    _ = aln_bfs_scored(aln, lengths; max_depth = 1, max_dup = 2, silent = true)
    index_map, best = aln_bfs_scored(
        aln, lengths;
        max_depth = opt["maxdepth"],
        max_dup = opt["maxdup"],
        max_count = opt["maxwidth"],
        max_offset = opt["maxoffset"])
    trajectories = get_good_trajectories(
        index_map, best;
        suboptimality = opt["minreport"],
        max_depth = opt["maxdepth"],
        max_report = opt["maxreport"])
    write_trajectories(opt["out_path"], trajectories)
    return 0
end

main()